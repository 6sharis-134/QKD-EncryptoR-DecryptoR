# -*- coding: utf-8 -*-
"""CapstoneProject_HarisSaifi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qL0uGsmNsdqR5P62jf80oRscwZF19dAt

#Installing the Cirq module
We will install the cirq module which will be used to create the Quantum Key Distribution for our message Encryptor and Decryptor function.
"""

!pip install cirq

"""#Import the required libraries
We will import the cirq library so that we can access all the modules of it for our Quantum Key Distribution like measurement, simulation, appending for the circuit and the qubits.
"""

import cirq
import numpy as np

"""#Quantum Key
In this section we will create the main unit for our uninterrupted/secured gateway for our messaging chanel.
the Quantum_Key() function will be responsible for creating the special key which will be used by the Sender(Alice) and the Receiver(Bob) for their message such that this key will help in disguising their message in between when the message is sent by the Alice(Sender) but not received by the Bob(Receiver) and this key will make sure that the message information is not hijacked by any intruder in our case "Eavesdropper". Or in athoer word this key will make sure that there will be no "Evesdropping".
"""

def Quantum_Key(Num_Bits):
  Qubits=[cirq.GridQubit(i,0) for i in range(Num_Bits)]
  Circuit=cirq.Circuit()
  for Qubit in Qubits:
    Circuit.append(cirq.H(Qubit))
  Circuit.append(cirq.measure(*Qubits, key='result'))
  return Circuit

def Measure_Quantum_Key(Circuit):
  Simulator=cirq.Simulator()
  Results=Simulator.run(Circuit,repetitions=1)
  measurements=[int(result) for result in Results.measurements['result'][0]]
  return measurements

"""#EncryptoR()
The EncryptoR() will be used by the Alice to the message along with the Key to disguise\disfigure it so that it maintains the security against the "Eavesdropper". EncryptoR() will take the Message and Key as assignments and apply some logical cryptography protocol so that our message meaning is get disfigured and it will hold no meaning if it get stolen during the communication.
"""

def EncryptoR(Message, Key):
  Key_length=len(Key)
  Message_length=len(Message)
  if Key_length<Message_length:
    Key=Key*(Message_length//Key_length)+Key[:Message_length%Key_length]
  elif Key_length>Message_length:
    Key=Key[:Message_length]
  encrypted_message=""
  for i in range(len(Message)):
    encrypted_message += chr(ord(Message[i])^Key[i])
  return encrypted_message

"""#DecryptoR()
The DecryptoR() will be used by the Bob to the message along with the Key to transform it to the orignal form to retrive out the actual information send by the Alice. DecryptoR() will take the Encrypted Message and Key as their assignments and apply some logical cryptography protocol in such a way that we will get the orignal message send by the Alice.
"""

def DecryptoR(encrypted_message,Key):
  Key_length=len(Key)
  encrypted_message_length=len(encrypted_message)
  if Key_length<encrypted_message_length:
    Key=Key*(encrypted_message_length//Key_length)+Key[:encrypted_message_length%Key_length]
  elif Key_length>encrypted_message_length:
    Key=Key[:encrypted_message_length]
  decrypted_message=""
  for i in range(len(encrypted_message)):
    decrypted_message += chr(ord(encrypted_message[i])^Key[i])
  return decrypted_message

"""#Sending our First Message.
Now we will use the EncryptoR() and DecryptoR() to send our Message.
"""

Num_Bits=7867
Message= "We are taught Quantum Computing by The \"The Coding School\", and they are amazing at it. We love you \"The Coding School\""
Key_Circuit=Quantum_Key(Num_Bits)
Key=Measure_Quantum_Key(Key_Circuit)

EncryptedMessage=EncryptoR(Message,Key)
DecryptedMessage=DecryptoR(EncryptedMessage,Key)
print(f"This is our orignal message: {Message}",f"This is our encrypted message: {EncryptedMessage}",f"This is the decrypted message: {DecryptedMessage}",sep="\n")